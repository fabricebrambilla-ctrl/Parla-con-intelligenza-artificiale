<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Parla con intelligenza artificiale</title>
  <style>
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: 0;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    :root {
      --bg: #eaf4ff;       /* very light blue */
      --card: #ffffff;
      --text: #0b1220;
      --btn: #0a66c2;
      --btnText: #ffffff;
      --btnDisabled: #9bb9db;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      text-align: center;
    }

    .wrap {
      width: min(720px, 92vw);
      background: var(--card);
      border-radius: 18px;
      padding: 28px 22px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
    }

    h1 {
      margin: 0 0 18px;
      font-size: 28px;
      line-height: 1.2;
    }

    .buttons {
      display: flex;
      gap: 14px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 16px;
    }

    button {
      font-size: 20px;
      padding: 16px 22px;
      border-radius: 14px;
      border: 0;
      cursor: pointer;
      min-width: 220px;
    }

    #startBtn {
      background: var(--btn);
      color: var(--btnText);
    }

    #stopBtn {
      background: #0b1220;
      color: #ffffff;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.55;
    }

    .hint {
      margin-top: 14px;
      font-size: 16px;
      opacity: 0.8;
    }
  </style>
</head>
<body>

  <div class="wrap">
  <h1>Parla con intelligenza artificiale</h1>

  <div class="buttons">
    <button id="startBtn">Inizia conversazione</button>
    <button id="stopBtn" disabled>Ferma ascolto</button>
  </div>

  <div class="hint">Parla normalmente. Se resti in silenzio per 5 secondi, l’app invia automaticamente.</div>

  <p id="status" class="sr-only" aria-live="polite">Inattivo</p>

  <!-- For screen readers (polite updates only; no forced focus) -->
  <div id="sr" class="sr-only" aria-live="polite" aria-atomic="true"></div>
  </div>


  <script>
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const statusEl = document.getElementById("status");
    const srEl = document.getElementById("sr");

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    // Multi-turn history: we send the whole conversation every time.
    const systemPrompt = "Rispondi in italiano. Usa un tono chiaro, calmo e accessibile per un utente non vedente.";
    const messages = [{ role: "system", content: systemPrompt }];

    let recognition;
    let finalTranscript = "";
    let lastPartial = "";
    let listening = false;

    // Stop timing/buffering so we don't miss the last words
    let stopRequested = false;
    let lastResultAt = 0;
    let finalizeTimer = null;
    let silenceTimer = null;
    let italianVoice = null;

    function sr(text) {
      // Polite update for screen readers
      srEl.textContent = text;
    }

    function pickItalianVoice() {
      try {
        if (!("speechSynthesis" in window)) return null;
        const voices = window.speechSynthesis.getVoices() || [];
        if (!voices.length) return null;

        // Prefer true Italian voices first
        const italian = voices.filter(v => {
          const lang = (v.lang || "").toLowerCase();
          const name = (v.name || "").toLowerCase();
          return lang.startsWith("it") || name.includes("italian") || name.includes("italiano");
        });

        const candidates = italian.length ? italian : voices;

        // Prefer local / system-quality voices when available
        candidates.sort((a, b) => {
          const aLocal = a.localService ? 1 : 0;
          const bLocal = b.localService ? 1 : 0;
          if (aLocal !== bLocal) return bLocal - aLocal;

          const aDefault = a.default ? 1 : 0;
          const bDefault = b.default ? 1 : 0;
          if (aDefault !== bDefault) return bDefault - aDefault;

          // Prefer names that often correspond to native Italian voices
          const aName = (a.name || "").toLowerCase();
          const bName = (b.name || "").toLowerCase();
          const prefs = ["luc", "alice", "elsa", "federica", "paolo", "silvia", "giorgio", "italian", "italiano"];
          const score = (n) => prefs.reduce((s, p) => s + (n.includes(p) ? 1 : 0), 0);
          return score(bName) - score(aName);
        });

        return candidates[0] || null;
      } catch {
        return null;
      }
    }

    // Voices often load asynchronously, especially on Safari.
    function ensureItalianVoice() {
      if (italianVoice) return;
      italianVoice = pickItalianVoice();
    }

    if ("speechSynthesis" in window) {
      window.speechSynthesis.onvoiceschanged = () => {
        italianVoice = null;
        ensureItalianVoice();
      };
      // Try once at startup
      ensureItalianVoice();
    }

    function speakIt(text) {
      try {
        if (!("speechSynthesis" in window)) return;

        ensureItalianVoice();

        // Stop any previous speech
        window.speechSynthesis.cancel();

        const u = new SpeechSynthesisUtterance(text);
        u.lang = "it-IT";

        // Force the best available Italian voice (this is what fixes the accent when a real Italian voice exists)
        if (italianVoice) u.voice = italianVoice;

        // Slightly slower improves intelligibility on some systems
        u.rate = 0.95;
        u.pitch = 1.0;

        window.speechSynthesis.speak(u);
      } catch (e) {
        console.error("TTS error:", e);
      }
    }
    // Optional debug: run in DevTools console -> listVoices()
    window.listVoices = function () {
      if (!("speechSynthesis" in window)) return [];
      const vs = window.speechSynthesis.getVoices() || [];
      console.table(vs.map(v => ({ name: v.name, lang: v.lang, localService: v.localService, isDefault: v.default })));
      return vs;
    };

    function startListening() {
      // Stop any ongoing AI speech immediately
      if ("speechSynthesis" in window) {
        window.speechSynthesis.cancel();
      }
      finalTranscript = "";
      lastPartial = "";
      listening = true;
      stopRequested = false;
      lastResultAt = Date.now();

      if (finalizeTimer) {
        clearInterval(finalizeTimer);
        finalizeTimer = null;
      }
      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }

      recognition = new SpeechRecognition();
      recognition.lang = "it-IT";
      recognition.interimResults = true;
      recognition.continuous = true;

      recognition.onstart = () => {
        statusEl.textContent = "In ascolto";
        sr("In ascolto. Premi Ferma ascolto quando hai finito.");
        startBtn.disabled = true;
        stopBtn.disabled = false;
        armSilenceFallback();
      };

      recognition.onresult = (event) => {
        armSilenceFallback();
        lastResultAt = Date.now();
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const text = res[0].transcript.trim();
          if (res.isFinal) {
            finalTranscript += " " + text;
            lastPartial = "";
          } else {
            lastPartial = text;
          }
        }
      };

      recognition.onend = () => {
        // If the user didn't press stop, keep listening across browser auto-stops
        if (listening && !stopRequested) {
          try { recognition.start(); } catch {}
        }
      };

      recognition.onerror = (e) => {
        listening = false;
        if (silenceTimer) {
          clearTimeout(silenceTimer);
          silenceTimer = null;
        }
        statusEl.textContent = "Errore";
        startBtn.disabled = false;
        stopBtn.disabled = true;
        sr("Errore nel riconoscimento vocale.");
        console.error("Speech error:", e);
      };

      try { recognition.start(); } catch {}
    }

    function buildFinalText() {
      let text = finalTranscript.trim();
      if (lastPartial) {
        if (!text.endsWith(lastPartial)) {
          text = (text + " " + lastPartial).trim();
        }
      }
      return text;
    }

    function armSilenceFallback() {
      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }
      // If no new speech results for 5 seconds, auto-finish
      silenceTimer = setTimeout(() => {
        if (!listening) return;
        stopListening();
      }, 5000);
    }

    async function sendToAI(userText) {
      // Add user turn to history
      messages.push({ role: "user", content: userText });
      sr("Sto pensando…");

      try {
        const r = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages })
        });

        if (!r.ok) {
          const t = await r.text();
          sr(`Errore HTTP ${r.status}`);
          console.error("HTTP error", r.status, t);
          return;
        }

        const data = await r.json();
        const assistantText = String(data?.reply || "").trim();

        if (!assistantText) {
          sr("Risposta vuota dal server.");
          return;
        }

        messages.push({ role: "assistant", content: assistantText });
        speakIt(assistantText);
        sr("Assistente: " + assistantText);
      } catch (err) {
        sr("Errore nel contattare il server.");
        console.error(err);
      }
    }

    function finalizeTranscriptAndRespond() {
      if (finalizeTimer) {
        clearInterval(finalizeTimer);
        finalizeTimer = null;
      }
      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }

      const text = buildFinalText();

      if (!text) {
        statusEl.textContent = "Inattivo";
        sr("Nessun testo rilevato.");
        return;
      }

      statusEl.textContent = "Invio del messaggio";
      sendToAI(text);
    }

    function stopListening() {
      if (!recognition) return;

      listening = false;
      stopRequested = true;
      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }

      statusEl.textContent = "Sto finendo…";
      sr("Sto finendo…");
      startBtn.disabled = false;
      stopBtn.disabled = true;

      try { recognition.stop(); } catch {}

      const startedAt = Date.now();

      if (finalizeTimer) {
        clearInterval(finalizeTimer);
        finalizeTimer = null;
      }

      // Check every 100ms: when idle for 600ms OR max 1500ms, finalize.
      finalizeTimer = setInterval(() => {
        const now = Date.now();
        const idleMs = now - lastResultAt;
        const totalMs = now - startedAt;

        if (idleMs >= 600 || totalMs >= 1500) {
          finalizeTranscriptAndRespond();
        }
      }, 100);
    }

    if (!SpeechRecognition) {
      statusEl.textContent = "Riconoscimento vocale non supportato.";
      startBtn.disabled = true;
      stopBtn.disabled = true;
    } else {
      startBtn.addEventListener("click", startListening);
      stopBtn.addEventListener("click", stopListening);
    }
  </script>

</body>
</html>